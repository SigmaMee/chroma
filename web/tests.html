<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Chroma Tests</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      padding: 2rem;
      background: #0a0a0a;
      color: #e0e0e0;
      line-height: 1.6;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 1rem;
      color: #fff;
    }

    h2 {
      font-size: 1.5rem;
      margin: 2rem 0 1rem;
      color: #fff;
    }

    .test-suite {
      margin-bottom: 2rem;
    }

    .test-case {
      padding: 1rem;
      margin: 0.5rem 0;
      border-radius: 8px;
      background: #1a1a1a;
      border-left: 4px solid #666;
    }

    .test-case.pass {
      border-left-color: #22c55e;
      background: #0f1f14;
    }

    .test-case.fail {
      border-left-color: #ef4444;
      background: #1f0f0f;
    }

    .test-name {
      font-weight: 600;
      margin-bottom: 0.5rem;
    }

    .test-result {
      font-size: 0.875rem;
      opacity: 0.8;
    }

    .test-error {
      color: #fca5a5;
      margin-top: 0.5rem;
      font-family: monospace;
      font-size: 0.875rem;
    }

    .summary {
      position: sticky;
      top: 0;
      background: #0a0a0a;
      padding: 1rem;
      border-radius: 8px;
      margin-bottom: 2rem;
      border: 1px solid #333;
    }

    .summary-item {
      display: inline-block;
      margin-right: 2rem;
      font-weight: 600;
    }

    .pass-count {
      color: #22c55e;
    }

    .fail-count {
      color: #ef4444;
    }

    .run-button {
      background: #3366ff;
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-size: 1rem;
      cursor: pointer;
      margin-bottom: 1rem;
    }

    .run-button:hover {
      background: #2952cc;
    }

    .run-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  </style>
</head>
<body>
  <h1>ðŸ§ª Chroma Test Suite</h1>
  
  <button class="run-button" id="runTests">Run All Tests</button>
  
  <div class="summary" id="summary">
    <span class="summary-item">Total: <span id="totalCount">0</span></span>
    <span class="summary-item pass-count">Passed: <span id="passCount">0</span></span>
    <span class="summary-item fail-count">Failed: <span id="failCount">0</span></span>
    <span class="summary-item">Duration: <span id="duration">0ms</span></span>
  </div>

  <div id="testResults"></div>

  <script type="module">
    // Import test utilities
    const testResults = [];
    let passCount = 0;
    let failCount = 0;

    // Test runner
    function assert(condition, message) {
      if (!condition) {
        throw new Error(message || 'Assertion failed');
      }
    }

    function assertEqual(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(message || `Expected ${expected}, got ${actual}`);
      }
    }

    function assertApprox(actual, expected, tolerance = 0.01, message) {
      if (Math.abs(actual - expected) > tolerance) {
        throw new Error(message || `Expected ~${expected}, got ${actual}`);
      }
    }

    function test(name, fn) {
      return {
        name,
        fn,
        suite: currentSuite
      };
    }

    let currentSuite = 'General';
    function suite(name, tests) {
      currentSuite = name;
      return tests;
    }

    // Hex validation tests
    const hexValidationTests = suite('Hex Validation', [
      test('validates correct hex colors', () => {
        const validHex = (hex) => /^#[0-9A-Fa-f]{6}$/.test(hex);
        assert(validHex('#3366FF'), 'Should accept uppercase hex');
        assert(validHex('#3366ff'), 'Should accept lowercase hex');
        assert(validHex('#000000'), 'Should accept black');
        assert(validHex('#FFFFFF'), 'Should accept white');
      }),

      test('rejects invalid hex colors', () => {
        const validHex = (hex) => /^#[0-9A-Fa-f]{6}$/.test(hex);
        assert(!validHex('3366FF'), 'Should reject hex without #');
        assert(!validHex('#36F'), 'Should reject 3-character hex');
        assert(!validHex('#3366GG'), 'Should reject invalid characters');
        assert(!validHex(''), 'Should reject empty string');
      }),

      test('normalizes hex colors', () => {
        const normalize = (hex) => hex.toUpperCase();
        assertEqual(normalize('#3366ff'), '#3366FF', 'Should normalize to uppercase');
      })
    ]);

    // Color conversion tests
    const conversionTests = suite('Color Conversion', [
      test('converts hex to RGB', () => {
        function hexToRgb(hex) {
          const r = parseInt(hex.slice(1, 3), 16);
          const g = parseInt(hex.slice(3, 5), 16);
          const b = parseInt(hex.slice(5, 7), 16);
          return { r, g, b };
        }
        
        const white = hexToRgb('#FFFFFF');
        assertEqual(white.r, 255);
        assertEqual(white.g, 255);
        assertEqual(white.b, 255);
        
        const black = hexToRgb('#000000');
        assertEqual(black.r, 0);
        assertEqual(black.g, 0);
        assertEqual(black.b, 0);
      }),

      test('converts hex to HSL', () => {
        function hexToHsl(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          let h, s, l = (max + min) / 2;
          
          if (max === min) {
            h = s = 0;
          } else {
            const d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
              case g: h = ((b - r) / d + 2) / 6; break;
              case b: h = ((r - g) / d + 4) / 6; break;
            }
          }
          
          return { h: h * 360, s: s * 100, l: l * 100 };
        }
        
        const blue = hexToHsl('#3366FF');
        assertApprox(blue.h, 220, 5, 'Blue hue should be around 220Â°');
        assert(blue.s > 0, 'Blue should have saturation');
        assert(blue.l > 0 && blue.l < 100, 'Lightness should be between 0-100');
      })
    ]);

    // Contrast calculation tests
    const contrastTests = suite('Contrast Calculation', [
      test('calculates relative luminance', () => {
        function getLuminance(hex) {
          const r = parseInt(hex.slice(1, 3), 16) / 255;
          const g = parseInt(hex.slice(3, 5), 16) / 255;
          const b = parseInt(hex.slice(5, 7), 16) / 255;
          
          const [rs, gs, bs] = [r, g, b].map(c => 
            c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
          );
          
          return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
        }
        
        const whiteLum = getLuminance('#FFFFFF');
        assertApprox(whiteLum, 1, 0.01, 'White luminance should be 1');
        
        const blackLum = getLuminance('#000000');
        assertApprox(blackLum, 0, 0.01, 'Black luminance should be 0');
      }),

      test('calculates contrast ratio', () => {
        function getContrast(hex1, hex2) {
          function getLuminance(hex) {
            const r = parseInt(hex.slice(1, 3), 16) / 255;
            const g = parseInt(hex.slice(3, 5), 16) / 255;
            const b = parseInt(hex.slice(5, 7), 16) / 255;
            
            const [rs, gs, bs] = [r, g, b].map(c => 
              c <= 0.03928 ? c / 12.92 : Math.pow((c + 0.055) / 1.055, 2.4)
            );
            
            return 0.2126 * rs + 0.7152 * gs + 0.0722 * bs;
          }
          
          const lum1 = getLuminance(hex1);
          const lum2 = getLuminance(hex2);
          const lighter = Math.max(lum1, lum2);
          const darker = Math.min(lum1, lum2);
          
          return (lighter + 0.05) / (darker + 0.05);
        }
        
        const blackWhite = getContrast('#000000', '#FFFFFF');
        assertApprox(blackWhite, 21, 0.1, 'Black/white contrast should be 21:1');
        
        const sameSame = getContrast('#3366FF', '#3366FF');
        assertApprox(sameSame, 1, 0.01, 'Same color contrast should be 1:1');
      }),

      test('validates WCAG compliance levels', () => {
        function meetsWCAG(ratio, level) {
          if (level === 'AAA') return ratio >= 7;
          if (level === 'AA') return ratio >= 4.5;
          return ratio >= 3; // AA Large
        }
        
        assert(meetsWCAG(21, 'AAA'), '21:1 meets AAA');
        assert(meetsWCAG(7, 'AAA'), '7:1 meets AAA');
        assert(!meetsWCAG(6, 'AAA'), '6:1 fails AAA');
        assert(meetsWCAG(4.5, 'AA'), '4.5:1 meets AA');
        assert(!meetsWCAG(4, 'AA'), '4:1 fails AA');
      })
    ]);

    // Token structure tests
    const tokenTests = suite('Token Structure', [
      test('generates valid W3C token structure', () => {
        const mockToken = {
          "color": {
            "primary": {
              "50": {
                "$type": "color",
                "$value": "#E5ECFF"
              }
            }
          }
        };
        
        assert(mockToken.color, 'Should have color namespace');
        assert(mockToken.color.primary, 'Should have primary scale');
        assert(mockToken.color.primary["50"], 'Should have step 50');
        assert(mockToken.color.primary["50"].$type === "color", 'Should have $type');
        assert(mockToken.color.primary["50"].$value, 'Should have $value');
      }),

      test('validates token reference syntax', () => {
        const isReference = (value) => typeof value === 'string' && value.startsWith('{') && value.endsWith('}');
        
        assert(isReference('{color.seed.primary}'), 'Should recognize reference');
        assert(!isReference('#3366FF'), 'Should not recognize hex as reference');
        assert(!isReference(''), 'Should not recognize empty as reference');
      })
    ]);

    // Scale generation tests
    const scaleTests = suite('Scale Generation', [
      test('generates correct number of steps', () => {
        const steps = [50, 100, 200, 300, 400, 500, 600, 700, 800, 900, 950];
        assertEqual(steps.length, 11, 'Should generate 11 steps');
        assertEqual(steps[0], 50, 'First step should be 50');
        assertEqual(steps[10], 950, 'Last step should be 950');
      }),

      test('maintains monotonic lightness', () => {
        // Lightness should decrease from 50 to 950
        const mockLightness = [95, 90, 80, 70, 60, 50, 40, 30, 20, 10, 5];
        
        for (let i = 1; i < mockLightness.length; i++) {
          assert(mockLightness[i] < mockLightness[i - 1], 
            `Step ${i} lightness should be less than step ${i - 1}`);
        }
      })
    ]);

    // Performance tests
    const performanceTests = suite('Performance', [
      test('debounce prevents excessive calls', (done) => {
        let callCount = 0;
        function debounce(fn, delay) {
          let timeout;
          return (...args) => {
            clearTimeout(timeout);
            timeout = setTimeout(() => fn(...args), delay);
          };
        }
        
        const debouncedFn = debounce(() => callCount++, 50);
        
        // Call multiple times quickly
        debouncedFn();
        debouncedFn();
        debouncedFn();
        
        // Should only execute once after delay
        setTimeout(() => {
          assertEqual(callCount, 1, 'Should only call once after debounce');
          done();
        }, 100);
      }),

      test('LRU cache limits size', () => {
        class LRUCache {
          constructor(maxSize) {
            this.maxSize = maxSize;
            this.cache = new Map();
          }
          
          set(key, value) {
            if (this.cache.has(key)) {
              this.cache.delete(key);
            } else if (this.cache.size >= this.maxSize) {
              const firstKey = this.cache.keys().next().value;
              this.cache.delete(firstKey);
            }
            this.cache.set(key, value);
          }
          
          get(key) {
            if (!this.cache.has(key)) return undefined;
            const value = this.cache.get(key);
            this.cache.delete(key);
            this.cache.set(key, value);
            return value;
          }
        }
        
        const cache = new LRUCache(3);
        cache.set('a', 1);
        cache.set('b', 2);
        cache.set('c', 3);
        assertEqual(cache.cache.size, 3, 'Cache should have 3 items');
        
        cache.set('d', 4);
        assertEqual(cache.cache.size, 3, 'Cache should still have 3 items');
        assertEqual(cache.get('a'), undefined, 'Oldest item should be evicted');
      })
    ]);

    // Collect all tests
    const allTests = [
      ...hexValidationTests,
      ...conversionTests,
      ...contrastTests,
      ...tokenTests,
      ...scaleTests,
      ...performanceTests
    ];

    // Run tests
    async function runTests() {
      const button = document.getElementById('runTests');
      button.disabled = true;
      button.textContent = 'Running...';
      
      testResults.length = 0;
      passCount = 0;
      failCount = 0;
      
      const startTime = performance.now();
      
      for (const test of allTests) {
        try {
          // Handle async tests
          if (test.fn.length > 0) {
            await new Promise((resolve) => {
              test.fn(resolve);
            });
          } else {
            test.fn();
          }
          
          testResults.push({
            name: test.name,
            suite: test.suite,
            passed: true
          });
          passCount++;
        } catch (error) {
          testResults.push({
            name: test.name,
            suite: test.suite,
            passed: false,
            error: error.message
          });
          failCount++;
        }
      }
      
      const duration = Math.round(performance.now() - startTime);
      
      // Update summary
      document.getElementById('totalCount').textContent = allTests.length;
      document.getElementById('passCount').textContent = passCount;
      document.getElementById('failCount').textContent = failCount;
      document.getElementById('duration').textContent = duration + 'ms';
      
      // Render results
      renderResults();
      
      button.disabled = false;
      button.textContent = 'Run All Tests';
    }

    function renderResults() {
      const container = document.getElementById('testResults');
      container.innerHTML = '';
      
      let currentSuite = null;
      
      testResults.forEach(result => {
        if (result.suite !== currentSuite) {
          currentSuite = result.suite;
          const suiteHeader = document.createElement('h2');
          suiteHeader.textContent = currentSuite;
          container.appendChild(suiteHeader);
        }
        
        const testCase = document.createElement('div');
        testCase.className = `test-case ${result.passed ? 'pass' : 'fail'}`;
        
        const testName = document.createElement('div');
        testName.className = 'test-name';
        testName.textContent = `${result.passed ? 'âœ“' : 'âœ—'} ${result.name}`;
        testCase.appendChild(testName);
        
        const testResult = document.createElement('div');
        testResult.className = 'test-result';
        testResult.textContent = result.passed ? 'Passed' : 'Failed';
        testCase.appendChild(testResult);
        
        if (!result.passed && result.error) {
          const errorDiv = document.createElement('div');
          errorDiv.className = 'test-error';
          errorDiv.textContent = result.error;
          testCase.appendChild(errorDiv);
        }
        
        container.appendChild(testCase);
      });
    }

    // Auto-run on load
    document.getElementById('runTests').addEventListener('click', runTests);
    window.addEventListener('load', runTests);
  </script>
</body>
</html>
